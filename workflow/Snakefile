import pandas as pd

snakemake.utils.min_version("9.0.0")

# Define wrapper versions
wrapper_ver = "v6.0.1"

# Default value for testing purposes
units = config.get(
    "units",
    pd.read_table(
        "config/units.tsv",
        converters={"seq_type": (lambda x: x.casefold())},
        comment="#",
    ).set_index(["sample", "library", "lane"], drop=False),
)
snakemake.utils.validate(
    units, schema=Path(workflow.current_basedir) / "schemas/units.schema.yaml"
)
# Default value for testing purposes
config = config.get("cfg", config)
snakemake.utils.validate(
    config, schema=Path(workflow.current_basedir) / "schemas/config.schema.yaml"
)


include: "rules/utils.smk"
include: "rules/raw.smk"
include: "rules/trim.smk"


#####################
### Read Trimming ###
#####################
rule multiqc:
    input:
        ### FastQC raw
        expand_pd(
            get_rule_stats("fastqc_raw"),
            units[~is_units_align(units)].explode("read_type_raw"),
        ),
        ### Trimming
        expand_pd(
            get_rule_stats(
                "{trimmer}_fastq_pe".format(trimmer=config["trim"]["tool"])
            ),
            units[~is_units_align(units) & units.seq_type.eq("pe")].explode(
                "read_type_raw"
            ),
        )
        if is_activated("trim")
        else [],
        expand_pd(
            get_rule_stats(
                "{trimmer}_fastq_se".format(trimmer=config["trim"]["tool"])
            ),
            units[~is_units_align(units) & units.seq_type.eq("se")].explode(
                "read_type_raw"
            ),
        )
        if is_activated("trim")
        else [],
        ### FastqQC trimmed
        expand_pd(
            get_rule_stats("fastqc_trim"),
            units[~is_units_align(units)].explode("read_type_trim"),
        )
        if is_activated("trim")
        else [],
    output:
        html="reports/multiqc.html",
        data="reports/multiqc_data.zip",
    log:
        "logs/reports/multiqc.log",
    benchmark:
        "benchmarks/reports/multiqc.log"
    params:
        extra="--force --clean-up " + config.get("report", {}).get("multiqc", ""),
    localrule: True
    threads: 1
    resources:
        mem=lambda w, attempt: f"{10* attempt} GiB",
        runtime=lambda w, attempt: f"{30* attempt} m",
    wrapper:
        f"{wrapper_ver}/bio/multiqc"


rule all:
    input:
        qc=rules.multiqc.output.html,
        res=(
            expand_pd(
                "results/reads/trim/{sample}_{library}_{lane}_{read_type_trim}.fastq.gz",
                units.explode("read_type_trim"),
            )
            if is_activated("trim")
            else []
        ),
    message:
        "Read trimming finished successfully!"
    default_target: True
