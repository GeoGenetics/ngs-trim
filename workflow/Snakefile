import pandas as pd

snakemake.utils.min_version("9.13.5")

######################
### Validate Input ###
######################
from urllib.parse import urlparse, urlunparse

baseurl = urlparse(workflow.current_basedir.get_path_or_uri(secret_free=True))
# Units (default value for testing purposes)
units = config.get(
    "units",
    pd.read_table(
        "config/units.tsv",
        converters={"seq_type": (lambda x: x.casefold())},
        comment="#",
    ).set_index(["sample", "library", "lane"], drop=False),
)
snakemake.utils.validate(
    units,
    schema=urlunparse(
        baseurl._replace(path=str(Path(baseurl.path) / "schemas" / "units.schema.yaml"))
    ),
)
# Config (default value for testing purposes)
config = config.get("cfg", config)
snakemake.utils.validate(
    config,
    schema=urlunparse(
        baseurl._replace(
            path=str(Path(baseurl.path) / "schemas" / "config.schema.yaml")
        )
    ),
)


#####################
### Read Trimming ###
#####################
include: "rules/utils.smk"
include: "rules/raw.smk"
include: "rules/trim.smk"


rule multiqc:
    input:
        ### FastQC raw
        expand_pd(
            get_rule_stats("fastqc_raw"),
            units[~is_units_align(units)].explode("read_type_raw"),
        ),
        ### Trimming
        expand_pd(
            get_rule_stats(
                "{trimmer}_fastq_pe".format(trimmer=config["trim"]["tool"])
            ),
            units[~is_units_align(units) & units.seq_type.eq("pe")].explode(
                "read_type_raw"
            ),
        )
        if is_activated("trim")
        else [],
        expand_pd(
            get_rule_stats(
                "{trimmer}_fastq_se".format(trimmer=config["trim"]["tool"])
            ),
            units[~is_units_align(units) & units.seq_type.eq("se")].explode(
                "read_type_raw"
            ),
        )
        if is_activated("trim")
        else [],
        ### FastqQC trimmed
        expand_pd(
            get_rule_stats("fastqc_trim"),
            units[~is_units_align(units)].explode("read_type_trim"),
        )
        if is_activated("trim")
        else [],
    output:
        html="reports/multiqc.html",
        data="reports/multiqc_data.zip",
    log:
        "logs/reports/multiqc.log",
    benchmark:
        "benchmarks/reports/multiqc.jsonl"
    params:
        extra="--force --clean-up " + config.get("report", {}).get("multiqc", ""),
    localrule: True
    threads: 1
    resources:
        mem=lambda w, attempt: f"{10* attempt} GiB",
        runtime=lambda w, attempt: f"{30* attempt} m",
    wrapper:
        "v7.9.1/bio/multiqc"


rule all:
    input:
        qc=rules.multiqc.output.html,
        res=(
            expand_pd(
                "results/reads/trim/{sample}_{library}_{lane}_{read_type_trim}.fastq.gz",
                units.explode("read_type_trim"),
            )
            if is_activated("trim")
            else []
        ),
    message:
        "Read trimming finished successfully!"
    default_target: True
